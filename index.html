<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2019-07-25 Thu 07:43 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Linear Systems - Part 2:  Clojure</title>
<meta name="generator" content="Org mode">
<meta name="author" content="George Kontsevich">
<meta name="description" content="Some linear algebra in Clojure"
>
<link rel="stylesheet" type="text/css" href="../web/worg.css" />
<link rel="shortcut icon" href="../web/panda.svg" type="image/x-icon">
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="../MathJax/MathJax.js?config=TeX-AMS_CHTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=".."> UP </a>
 |
 <a accesskey="H" href=".."> HOME </a>
</div><div id="content">
<h1 class="title">Linear Systems - Part 2:  Clojure</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org4c85296">Preface</a>
<ul>
<li><a href="#orgea32694">Neanderthal</a></li>
</ul>
</li>
<li><a href="#org9235c5a">Project managment</a></li>
<li><a href="#orgc6f03de">Householder QR</a>
<ul>
<li><a href="#org32eb5e6">elementary reflector</a>
<ul>
<li><a href="#orge36bdd6">the code</a></li>
</ul>
</li>
<li><a href="#orgb469a98">elementary coordinate reflector</a></li>
<li><a href="#orge168066">Zeroing the first column</a></li>
<li><a href="#org07fd774">Zeroing out the second column</a>
<ul>
<li><a href="#orgacb19fc">Reducing to R in code</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orge0e0735"><span class="todo TODO">TODO</span> s</a></li>
<li><a href="#org09a2706">SRC<sub>Block</sub> template</a></li>
<li><a href="#org7d47db7">End</a></li>
</ul>
</div>
</div>

<div id="outline-container-org4c85296" class="outline-2">
<h2 id="org4c85296">Preface</h2>
<div class="outline-text-2" id="text-org4c85296">
<p>
This is a continuation (with some overlap) of what I have been developing in <a href="http://geokon-gh.github.io/linearsystems-part1/index.html">Part 1</a>. There I had developed a linear algebra system from scratch in ELisp and showed how to use it in several different fundamental applications. However as the algorithms become more complicated, the code started to get a little out of hand. A larger fraction of the time and code was spent on helper functions and extending the system to support different operations I needed and certain design simplifications and errors I had made at the beginning made the ultimate system inflexible and a bit unsatifying to work with.
</p>
</div>

<div id="outline-container-orgea32694" class="outline-3">
<h3 id="orgea32694">Neanderthal</h3>
<div class="outline-text-3" id="text-orgea32694">
<p>
To carry on working a bit less encumbered with my own mistakes and to push my comfort zone a bit, I've switched over to Clojure and the <code>neanderthal</code> library. The library provides a wrapper for the Intel <code>BLAS</code> library called <code>Intel MKL</code>. It's probably the most optimized solution out there for running linear algebra on the CPU. If you look at <a href="https://neanderthal.uncomplicate.org/codox/uncomplicate.neanderthal.core.html">the documentation</a>, some additional functionality that I was missing is now available, but at the same time lots of little conveniences are missing. Typically this means that these features have performance issues and so we will need to look for alternatives.
</p>

<blockquote>
<p>
<b>Note</b> I don't <i>actually</i> know how to use BLAS/Neanderthal properly and I'm winging it and figuring things out as I go along. If there are mistakes please please make an issue
</p>
</blockquote>

<p>
As before, this is an org document and can be tangled into the full Clojure project without the need for any external files. The tangled output will also be tracked in the repository, (but is not necessary if you use Emacs)
</p>

<p>
Explaining Clojure is outside the scope of this project, but in short you will need to install Java and <a href="http://leiningen.org/">Leiningen</a> and the intel MKL (on Ubuntu 18.10 and higher this is a lot easier b/c it's all available in the offical repositories). After you have both installed, you just clone this repository, go into it, and run <code>lein run</code> to run the project or <code>lein repl</code> to start an interactive REPL session.
</p>
</div>
</div>
</div>

<div id="outline-container-org9235c5a" class="outline-2">
<h2 id="org9235c5a">Project managment</h2>
<div class="outline-text-2" id="text-org9235c5a">
<p>
Project management in Clojure is done through a top level <code>leiningen</code> file <code>project.clj</code>  which specifies dependencies and other details.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #0000FF;">defproject</span> <span style="color: #006699;">linearsystems-part2</span> <span style="color: #008000;">"0.1.0-SNAPSHOT"</span>
  <span style="color: #D0372D;">:description</span> <span style="color: #008000;">"linea-systems in Clojure"</span>
  <span style="color: #D0372D;">:url</span> <span style="color: #008000;">"http://geokon-gh.github.io/linearsystems-part2/index.html"</span>
  <span style="color: #D0372D;">:license</span> {<span style="color: #D0372D;">:name</span> <span style="color: #008000;">"Eclipse Public License"</span>
            <span style="color: #D0372D;">:url</span> <span style="color: #008000;">"http://www.eclipse.org/legal/epl-v10.html"</span><span style="color: #999999;">}</span>
  <span style="color: #D0372D;">:dependencies</span> [[<span style="color: #6434A3;">org.clojure</span>/clojure <span style="color: #008000;">"1.10.0"</span><span style="color: #999999;">]</span>
                 [<span style="color: #6434A3;">uncomplicate</span>/neanderthal <span style="color: #008000;">"0.22.0"</span><span style="color: #999999;">]]</span>
  <span style="color: #D0372D;">:main</span> ^<span style="color: #D0372D;">:skip-aot</span> linearsystems-part2.core
  <span style="color: #D0372D;">:target-path</span> <span style="color: #008000;">"target/%s"</span>
  <span style="color: #D0372D;">:profiles</span> {<span style="color: #D0372D;">:uberjar</span> {<span style="color: #D0372D;">:aot</span> <span style="color: #D0372D;">:all</span><span style="color: #999999;">}})</span>

</pre>
</div>
<p>
The rest of the code will live in <code>src/core.clj</code> as is the convention (maybe if there is a lot of code or parts to break off, these will be in separate namespaces/files..)
We start by declaring the project namespace and including all of <code>neanderthal</code>. Since we will be using it extensively and I don't want to overload any of its names, I'm not even bothering to alias it.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #0000FF;">ns</span> <span style="color: #6434A3;">linearsystems-part2.core</span>
  (<span style="color: #D0372D;">:use</span> [uncomplicate.neanderthal core native<span style="color: #999999;">])</span>
  (<span style="color: #D0372D;">:gen-class</span><span style="color: #999999;">))</span>

(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">-main</span>
  <span style="color: #036A07;">"I don't do a whole lot ... yet."</span>
  [&amp; args<span style="color: #999999;">]</span>
  (println <span style="color: #008000;">"Hello, World!"</span><span style="color: #999999;">))</span>

</pre>
</div>
<p>
The <code>-main</code> is just a placeholder for the moment. With the setup out of the way, we can move on to the actual matrix magic
</p>
</div>
</div>

<div id="outline-container-orgc6f03de" class="outline-2">
<h2 id="orgc6f03de">Householder QR</h2>
<div class="outline-text-2" id="text-orgc6f03de">
<p>
An alternate method to the Gram-Schmidt is to take a more direct approach to building a <b>QR</b> matrix - similar to how we worked on building the <b>LU</b>. We will just directly zero out columns to build an upper triangular <b>R</b>. The difference from the <b>LU</b> is that now instead of using elementary matrices to do row operations to get zeroes we will restrict ourselves to using <b>elementary reflectors</b>. Their key property is that they are orthonormal, so when we carry out a series of reflections <b>Q<sub>1</sub>Q<sub>2</sub>..Q<sub>k</sub>A</b> we can combine them into one matrix which will be guaranteed to be orthonormal as well. Conceptually this is saying that if you do a bunch of reflections one after another, it all adds up in the end to be one reflection - and this makes some intuitive sense. In the <b>LU</b>'s Gaussian elimination the elementary matrices we used were neither orthogonal nor normal and we didn't have this same guarantee that the product of several elementary matrices gives another elementary matrix.
</p>
</div>


<div id="outline-container-org32eb5e6" class="outline-3">
<h3 id="org32eb5e6">elementary reflector</h3>
<div class="outline-text-3" id="text-org32eb5e6">
<p>
An <i>elementary reflector</i> does what's written on the label, it's a matrix/linear-system which when given a vector produces its reflection across a <i>N-1</i> dimensional hyperplane. In the next section we will deal with selecting the correct hyperplane, but for the time being we will just focus on building such a matrix. 
</p>

<p>
The first task is finding a nice concise mechanism to define a hyperplane. If our space is <b>R<sup>N</sup></b> then the hyperplane will be <b>N-1</b> dimensions and at first blush we seem to need <b>N-1</b> vectors to define it. For instance in <b>3D</b> space any two vectors not on the same line will define a <b>2D</b>. Where <b>plane = a*v<sub>1</sub> + b*v<sub>2</sub></b> <i>for all a and b</i>. But this method doesn't really scale b/c as <b>N</b> increases so does the number of vectors you need. The shortcut is that actually all planes have vectors orthogonal to the hyper plane. These vectors all lie on the same line and we just choose one, call it <b>u</b>, and let it represent that remaining <b>N<sup>th</sup></b> dimension. Now you can simply say that the hyperplane is all vectors orthogonal to <b>u</b>. Or more formally, all vectors <i>not-in-the-span</i> of <b>u</b> are the hyperplane
</p>

<p>
Now that we have a way to define a plane we need to work through the mechanics of relfecting an arbitrary vector <b>x</b> across the hyperplane. The key insight here is that <b>x</b> can be treated as two separate vectors. One that lies in the plane and one that is orthogonal to the plane. The component that lies in the plane is unaffected by the reflection while the component that is orthogonal is basically flipped to point to the other side of the plane. To do this procedure mathematically we take the component of <b>x</b> in the direction of the <b>u</b> that defines our plane and then we subtract it twice from <b>x</b>. This will give us a new vector that points at its own reflection on the other side of the plane. Breaking it down further, the steps go as followed:
</p>
<ul class="org-ul">
<li><b>u<sup>t</sup>x*/||u||</b> is the amount of <b>x</b> in the direction of <b>u</b> (a scalar)</li>
<li><b>uu<sup>t</sup>x/||u||<sup>2</sup></b> is the component <b>x</b> in the direction of <b>u</b> (a vector)</li>
<li>Here we notice that we can subsitute the inner product <b>u<sup>t</sup>u</b> for <b>||u||<sup>2</sup></b></li>
<li><b>uu<sup>t</sup>x/u<sup>t</sup>u</b></li>
<li><b>x - 2uu<sup>t</sup>x/u<sup>t</sup>u</b> is you subtracting that vector component twice to get its reflection</li>
<li><b>(I-2uu<sup>t</sup>/u<sup>t</sup>u)x</b> is how we'd factor the <b>x</b> back out</li>
<li><b>(I-2uu<sup>t</sup>/u<sup>t</sup>u)</b> represents the reflector matrix. It's defined uniquely by the <b>u</b> vector!</li>
</ul>
<p>
Note that now that we factored out this matrix that given any new value of <b>x</b> we can multiply it by <b>(I-2uu<sup>t</sup>/u<sup>t</sup>u)</b> and get its reflection across the hyperplane orthogonal to <b>u</b>. 
</p>

<p>
<b>Note:</b> We will see in the next section that we can't safely assume <b>u</b> is unit length - otherwise we could drop the normalizing inner product term and everything would look much cleaner.
</p>
</div>

<div id="outline-container-orge36bdd6" class="outline-4">
<h4 id="orge36bdd6">the code</h4>
<div class="outline-text-4" id="text-orge36bdd6">
<p>
This will be our first foray into working with Intel BLAS and neanderthal and it's good to have a big picture understanding of how working with this library will be quite different from working in ELisp. First of all we will need to be a lot more conscious of where our data is and we will need to make more effort in avoiding any needless copying. The available functions are split into several general categories. There are functions that change data in place (they end in an <code>!</code>), there are generally identical functions that will copy the result into a new matrix/vector/etc. and finally there are functions that don't copy or write anything but simply return a new interface to the same underlying data.
</p>

<p>
Next, unlike in MATLAB, vectors are not treated just as column matrices as you see in most literature. At first this is a bit annoying, but the rational is sound and a good explanation of this design decision is here: <a href="https://github.com/mikera/core.matrix/wiki/Vectors-vs.-matrices">https://github.com/mikera/core.matrix/wiki/Vectors-vs.-matrices</a> and here: <a href="https://groups.google.com/d/topic/numerical-clojure/zebBCa68eTw/discussion">https://groups.google.com/d/topic/numerical-clojure/zebBCa68eTw/discussion</a>
</p>

<p>
To start we need to make an identity matrix. For some reason this isn't part of <code>Neanderthal</code> nor <code>IntelMKL</code>. I'm not quite sure why, maybe because depending on your use-case you will want to put it in a different matrix container (triangular, dense, symmetrical etc.). In any case.. for our usecase we will just use the diagonal. If this becomes problematic later we can revisit this:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">identity-matrix</span>
  <span style="color: #036A07;">"Create an identity matrix of DIMENSION"</span>
  [dimension<span style="color: #999999;">]</span>
  (entry! (dgd dimension) 1<span style="color: #999999;">))</span>
</pre>
</div>
<ul class="org-ul">
<li><code>dgd</code> creates a <i>diagonal matrix</i> (this is a more compact matrix representation than a full dense matrix)</li>
<li><code>entry!</code> set the values in the matrix to some value</li>
</ul>

<p>
Next we will need to add a <code>self-outer-product</code> function to calculate the <b>uu<sup>t</sup></b> in our reflection matrix equation. At first it seems like there doesn't existing a function for this <code>neaderthal</code> or <code>Intel BLAS</code> - but it's actually kinda hidden in the <code>(rk ..)</code>. This the <b>Rank 1 Update</b> function.. which is used to update <b>QR</b> decompositions when we get new data.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">self-outer-product</span>
  <span style="color: #036A07;">"Returns the outer product of a vector with itself"</span>
  [input-vector<span style="color: #999999;">]</span>
  (view-sy (rk input-vector
               input-vector<span style="color: #999999;">)))</span>
</pre>
</div>

<p>
We have an added guarantee that the result with be symmetric b/c <b>(uu<sup>t</sup>)<sup>t</sup>=uu<sup>t</sup></b> so we can wrap the output in a <code>view-sy</code> which will make the result show up as a symmetric matrix.
</p>

<p>
Now that we have all the pieces we need we write out the equation for the elementary reflector. Give a <b>u</b> it'll return a reflector matrix.
</p>

<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">elementary-reflector</span>
  <span style="color: #036A07;">"Build a matrix that will reflect vectors across the hyperplane orthogonal to REFLECTION-AXIS"</span>
  [reflection-axis<span style="color: #999999;">]</span>
  (<span style="color: #0000FF;">let</span> [outer-product-matrix (self-outer-product reflection-axis<span style="color: #999999;">)]</span>
    (axpy!
     (dia (identity-matrix (dim reflection-axis<span style="color: #999999;">)))</span>
     (dia (scal! (/ -2 (dot reflection-axis reflection-axis<span style="color: #999999;">))</span>
                 outer-product-matrix<span style="color: #999999;">)))</span>
    outer-product-matrix<span style="color: #999999;">))</span>
</pre>
</div>

<ul class="org-ul">
<li><code>dim</code> returns the number of elements in the input vector</li>
<li><code>axpy!</code> in an in-place addition where the values are added "in-place" to the second matrix/vector. Here we're carrying out the subtraction step in <b>(I-2uu<sup>t</sup>/u<sup>t</sup>u)</b></li>
<li><code>dia</code> makes the diagonal elements of a matrix look like a vector. This is just a new view to the same underlying data in the input matrix so that even though we're adding 2 sectors it's actually adding the diagonal elements of the matrices under the hood.</li>
<li><code>scal!</code> is an in-place multiplication of a matrix by a scalar. Here the scalar is <b>-2/u<sup>t</sup>u</b> and the matrix is the outer product <b>uu<sup>t</sup></b>.</li>
</ul>

<p>
For example:
</p>
<div class="org-src-container">
<pre class="src src-clojure">(elementary-reflector (dv [43.0 36.0 38.0 90.0<span style="color: #999999;">]))</span>

<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">#RealUploMatrix[double, type:sy, mxn:4x4, layout:column, offset:0]</span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#9637;       &#8595;       &#8595;       &#8595;       &#8595;       &#9491;    </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;       0.71    *       *       *            </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;      -0.24    0.80    *       *            </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;      -0.26   -0.22    0.77    *            </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;      -0.61   -0.51   -0.54   -0.28         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#9495;                                       &#9499;   </span>


(mm (elementary-reflector (dv [43.0 36.0 38.0 90.0<span style="color: #999999;">]))</span>
  (dge 4
       1
       (dv [43.0 36.0 38.0 90.0<span style="color: #999999;">])))</span>

<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">#RealGEMatrix[double, mxn:4x1, layout:column, offset:0]</span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#9637;       &#8595;       &#9491;    </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;     -43.00         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;     -36.00         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;     -38.00         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;     -90.00         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#9495;               &#9499;  </span>
</pre>
</div>

<p>
This is subtle, but important: Notice how the output of <code>(elementary-reflector .. )</code> shows up as <code>#RealUploMatrix[..]</code> ie. as a symmetric matrix. Neanderthal has cascaded the original symmetric matrix <i>type</i> from <code>self-outer-product</code> all the way through all the operations we did b/c it knows they didn't change the symmetry. This is very powerful and useful! You can just imagine having to juggle the types in C/C++ .. 
</p>

<p>
<b>TODO</b> - Include Plot
</p>
</div>
</div>
</div>

<div id="outline-container-orgb469a98" class="outline-3">
<h3 id="orgb469a98">elementary coordinate reflector</h3>
<div class="outline-text-3" id="text-orgb469a98">
<p>
Circling back to our original intent, we were trying to use reflectors to clear rows and build an upper triangular matrix (the <b>Q</b> in the <b>QR</b>). 
</p>

<p>
The first thing we want to do is have a method to zero out the first column of a matrix, ie <b>A<sub> - ,1</sub></b>, If we could build a special elementary reflector <b>Q<sub>1</sub></b> that reflected that first column on to the elementary vector <b>e<sub>1</sub></b> (that's <b>[ 1 0 0 0.. 0 ]</b> ), then <b>Q<sub>1</sub>A</b> would leave everything under the the first column zeroed out
</p>

<p>
Generalizing a bit further, we will write a function that take a given vector and a target coordinate axis and produce a reflection matrix that takes one to the other. This is a bit of an inversion of what we did in the previous section. Instead of taking a hyperplane and reflecting over it, we now know what we want to reflect and where we want to reflect it to - we just need to find the right plane to do it. The answer isn't all that complicated, but it's a bit hard to picture. We want to find the plane that lies between where we start and where we want to reflect to. If you have two vectors and you want to make a plane that goes right between them, then all you need to do is make the two vectors the same length and add them together. This will give you a vector that goes right between the two. If you picture it in 2D space then the two vectors add up into a diamond shape with the point lieing on the bisecting line. 
</p>

<p>
The last catch is that to define out plane we actually want the orthogonal vector. However, if instead you subtract these two equal-length vectors, then you will find that you get a vector orthogonal to that bisection vector/plane.
</p>

\begin{equation}
u = x - ||x||e_{1}
\end{equation}

<p>
Once you have the orthogonal vector to the bisecting plane, you just feed it into our previous function and get the reflection matrix!
</p>
<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">elementary-coordinate-reflector</span>
  <span style="color: #036A07;">"Build a matrix that will reflect the INPUT-VECTOR on to the COORDINATE-AXIS"</span>
  [input-vector coordinate-axis<span style="color: #999999;">]</span>
  (scal! (nrm2 input-vector) coordinate-axis)   <span style="color: #8D8D84; font-style: italic;">; scale coordinate axis</span>
  (<span style="color: #0000FF;">if</span> (= input-vector coordinate-axis) <span style="color: #8D8D84; font-style: italic;">; degenerate case</span>
    (identity-matrix (dim input-vector))                           <span style="color: #8D8D84; font-style: italic;">; return identity matrix</span>
    (elementary-reflector (axpy -1                      <span style="color: #8D8D84; font-style: italic;">; make input-vector orthogonal to the bisecting plane</span>
                                coordinate-axis
                                input-vector<span style="color: #999999;">))))</span>
</pre>
</div>
<p>
For instance we can take some random vector and say we want to reflect it onto the <b>e<sub>1</sub></b>
</p>
<div class="org-src-container">
<pre class="src src-clojure">(elementary-coordinate-reflector (dv [24 77 89 12]) (dv [1 0 0 0<span style="color: #999999;">]))</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">#RealUploMatrix[double, type:sy, mxn:4x4, layout:column, offset:0]</span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#9637;       &#8595;       &#8595;       &#8595;       &#8595;       &#9491;    </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;       0.20    *       *       *            </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;       0.64    0.49    *       *            </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;       0.74   -0.59    0.32    *            </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;       0.10   -0.08   -0.09    0.99         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#9495;                                       &#9499;    </span>
</pre>
</div>
<p>
We got some seemingly random matrix out. If we then multiply it times out random vector, it reflects perfectly to <b>e<sub>1</sub></b>
</p>
<div class="org-src-container">
<pre class="src src-clojure">(mm (elementary-coordinate-reflector (dv [24 77 89 12<span style="color: #999999;">])</span>
                                     (dv [1 0 0 0<span style="color: #999999;">]))</span>
    (dge 4
         1
         (dv [24 77 89 12<span style="color: #999999;">])))</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">#RealGEMatrix[double, mxn:4x1, layout:column, offset:0]</span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#9637;       &#8595;       &#9491;    </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;     120.71         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;      -0.00         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;      -0.00         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;      -0.00         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#9495;               &#9499;    </span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge168066" class="outline-3">
<h3 id="orge168066">Zeroing the first column</h3>
<div class="outline-text-3" id="text-orge168066">
<p>
Now putting all the pieces together, given some matrix <b>A</b> we can get back a reflector to zero out its first column
</p>
<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">elementary-vector</span>
  <span style="color: #036A07;">"Make an elemntary vector of INDEX and DIMENSION"</span>
  [index dimension<span style="color: #999999;">]</span>
  (dv (assoc (into [] (repeat dimension 0)) index 1<span style="color: #999999;">)))</span>

(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">first-column-reflector</span>
  <span style="color: #036A07;">"Build a matrix that will reflect the INPUT-MATRIX such that the first column end up on [ 1 0 0 .. 0 ]"</span>
  [input-matrix<span style="color: #999999;">]</span>
  (elementary-coordinate-reflector (col input-matrix 0<span style="color: #999999;">)</span>
                                   (elementary-vector 0 (mrows input-matrix<span style="color: #999999;">))))</span>

<span style="color: #8D8D84;">;;</span><span style="color: #8D8D84; font-style: italic;">(dv (assoc (into [] (repeat (mrows input-matrix) 0)) 0 1))</span>
</pre>
</div>

<p>
Now we can test it by writing out a random matrix and zeroing out its first column
</p>
<div class="org-src-container">
<pre class="src src-clojure">(first-column-reflector (dge [[43.0 36.0 38.0 90.0<span style="color: #999999;">]</span>
                              [21.0 98.0 55.0 48.0<span style="color: #999999;">]</span>
                              [72.0 13.0 98.0 12.0<span style="color: #999999;">]</span>
                              [28.0 38.0 73.0 20.0<span style="color: #999999;">]]))</span>

<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">#RealUploMatrix[double, type:sy, mxn:4x4, layout:column, offset:0]</span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#9637;       &#8595;       &#8595;       &#8595;       &#8595;       &#9491;    </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;       0.47    *       *       *            </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;       0.23    0.90    *       *            </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;       0.79   -0.35   -0.19    *            </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;       0.31   -0.14   -0.46    0.82         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#9495;                                       &#9499;  </span>

(<span style="color: #0000FF;">let</span> [A (dge [[43.0 36.0 38.0 90.0<span style="color: #999999;">]</span>
              [21.0 98.0 55.0 48.0<span style="color: #999999;">]</span>
              [72.0 13.0 98.0 12.0<span style="color: #999999;">]</span>
              [28.0 38.0 73.0 20.0<span style="color: #999999;">]])]</span>
  (mm (first-column-reflector A<span style="color: #999999;">)</span>
      A<span style="color: #999999;">))</span>
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">#RealGEMatrix[double, mxn:4x4, layout:column, offset:0]</span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#9637;       &#8595;       &#8595;       &#8595;       &#8595;       &#9491;    </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;      90.87   61.69  130.83   69.35         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;      -0.00   86.73   14.28   57.06         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;      -0.00  -25.64  -41.61   43.06         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#8594;       0.00   22.97   18.71   32.08         </span>
<span style="color: #8D8D84;">;;    </span><span style="color: #8D8D84; font-style: italic;">&#9495;                                       &#9499;    </span>
</pre>
</div>

<p>
Now we hit a bit of a snag. You can use the same method to make some matrix <b>Q<sub>2</sub></b> that will zero out the second column, but when you combine the two and try <b>Q<sub>2Q</sub><sub>1A</sub></b> you will see that <b>Q<sub>2</sub></b> is messing up the first column - so we lose the progress we'd made in the first step. We may have gotten the first column to lie on the coordinate vector after <b>Q<sub>1A</sub></b>, but when you reflect it again it moves away from the coordinate vector.
</p>

<p>
In the <b>LU</b> Gaussian Elimination method we didn't have this problem b/c clearing subsequent columns was guaranteed to leave you previous columns intact (it would just shuffling zeroes around). Now this guarantee is gone so we need to think of a new trick.
</p>
</div>
</div>

<div id="outline-container-org07fd774" class="outline-3">
<h3 id="org07fd774">Zeroing out the second column</h3>
<div class="outline-text-3" id="text-org07fd774">
<p>
As is usually the trick with these things, the solution is thinking in terms of block matrices. When we say we need to clear the second column we actually mean taking the result of our <b>Q<sub>1A</sub></b> and clearing everything under the <code>(2,2)</code> position. To approach this we construct a new block matrix for <b>Q<sub>2</sub></b> that will have the form
</p>

\begin{equation}
Q_{2}
=
\begin{bmatrix}
1 & 0\\
0 & S_{ n-1, m-1 }\\
\end{bmatrix}
\end{equation}

<p>
Notice how when we multiply this matrix times <b>Q<sub>1A</sub></b> the first column is left untouched and this <code>(n-1,m-1)</code> submatrix <b>S</b> will multiple times a submatrix of <b>Q<sub>1A</sub></b> which has the <code>(2,2)</code> position now in the <code>(1,1)</code> position.
</p>


\begin{equation}
Q_2(Q_1A)
=
\begin{bmatrix}
1 & 0\\
0 & S\\
\end{bmatrix}
\begin{bmatrix}
(Q_{1}A)_{1,1} & (Q_{1}A)_{1,*}\\
0 & (Q_{1}A)_{n-1,m-1}\\
\end{bmatrix}
=
\begin{bmatrix}
(Q_{1}A)_{1,1} & (Q_{1}A)_{1,*}\\
0 & S(Q_{1}A)_{n-1,m-1}\\
\end{bmatrix}
\end{equation}

<p>
In the resulting matrix the only "new" entry we need to worry about is <b>S(Q<sub>1</sub>A)<sub>n-1,m-1</sub></b> - everything else is unchanged. In this submatrix we need to clear the first column because it's the second column of our overall matrix - and we are free to choose any appropriate <b>S</b> matrix to do it. At this point the problem of choosing <b>S</b> mirrors the process we used to clear the first column - the only difference being that the dimension is one smaller
</p>

<p>
When tackling the third column we just repeat the process but starting with the <b>S(Q<sub>1</sub>A)<sub>n-1,m-1</sub></b> matrix - so the method is starting to show some recursion
</p>
</div>

<div id="outline-container-orgacb19fc" class="outline-4">
<h4 id="orgacb19fc">Reducing to R in code</h4>
<div class="outline-text-4" id="text-orgacb19fc">
<p>
A recursive solution is already very promising, however thanks to BLAS and <code>neanderthal</code> we can actually go one step further because their APIs allow us to reference blocks using the <code>(submatrix ..)</code> function. This gives us a new matrixobject that we can manipulate on its own, but its underlying data will remain tied to the matrix we pulled it out of. So if we start modifying the submatrix its larger parent matrix will also change in turn
</p>

<p>
At each iteration of the algorithm, like when generating <b>Q<sub>2</sub>Q<sub>1</sub>A</b> we will want to grab the submatrix from the preceeding input matrix - so <b>(Q<sub>1</sub>A)<sub>n-1,m-1</sub></b> from <b>Q<sub>1</sub>A</b> in our example above - and we will want to "modify"/reflect this submatrix with <b>S</b> and then repeate the process with the next immediate submatrix. Looking at our <b>Q<sub>2</sub>Q<sub>1</sub>A</b> example we can already see that the rest of <b>Q<sub>1</sub>A</b> won't need to be changed - we just need to relfect that submatrix and that's it.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">reduce-to-r</span>
  <span style="color: #036A07;">"Reduce a matrix to a lower triangular orthonormal matrix"</span>
  [input-matrix<span style="color: #999999;">]</span>
  (<span style="color: #0000FF;">if</span> (= 1 (dim input-matrix)) <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">base case - 1x1 matrix .. nothing to reduce</span>
    (input-matrix<span style="color: #999999;">)</span>
    (<span style="color: #0000FF;">do</span> (mm! (first-column-reflector input-matrix<span style="color: #999999;">)</span>
             input-matrix<span style="color: #999999;">)</span>
        (<span style="color: #0000FF;">recur</span> (submatrix input-matrix
                           1
                           1
                           (dec (mrows input-matrix<span style="color: #999999;">))</span>
                           (dec(ncols input-matrix<span style="color: #999999;">)))))))</span>

</pre>
</div>

<p>
<b>WIP</b>: The above code doesn't work b/c unfortunately you can't <code>mm!</code> in place with a <a href="https://github.com/uncomplicate/neanderthal/issues/67">symmetric matrix</a>. So the algorithm needs to be reworked. It's unclear if it can be made to work in-place with no copying.
</p>
<div class="org-src-container">
<pre class="src src-clojure">(<span style="color: #0000FF;">let</span> [A (dge [[43.0 36.0 38.0 90.0<span style="color: #999999;">]</span>
                [21.0 98.0 55.0 48.0<span style="color: #999999;">]</span>
                [72.0 13.0 98.0 12.0<span style="color: #999999;">]</span>
                [28.0 38.0 73.0 20.0<span style="color: #999999;">]])]</span>
    (reduce-to-r A<span style="color: #999999;">))</span>

(<span style="color: #0000FF;">let</span> [A (dge [[43.0 36.0 38.0 90.0<span style="color: #999999;">]</span>
                [21.0 98.0 55.0 48.0<span style="color: #999999;">]</span>
                [72.0 13.0 98.0 12.0<span style="color: #999999;">]</span>
                [28.0 38.0 73.0 20.0<span style="color: #999999;">]])]</span>
    (mm! (first-column-reflector A<span style="color: #999999;">)</span>
         A<span style="color: #999999;">)</span>



</pre>
</div>

<p>
This process continues recursively to the third column and so on.. until we hit the 2x2 case and the whole matrix has been zeroed out.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orge0e0735" class="outline-2">
<h2 id="orge0e0735"><span class="todo TODO">TODO</span> s</h2>
<div class="outline-text-2" id="text-orge0e0735">
<ul class="org-ul">
<li>add some TODOs</li>
</ul>
</div>
</div>
<div id="outline-container-org09a2706" class="outline-2">
<h2 id="org09a2706">SRC<sub>Block</sub> template</h2>
<div class="outline-text-2" id="text-org09a2706">
<div class="org-src-container">
<pre class="src src-clojure">  (<span style="color: #0000FF;">defn</span> <span style="color: #006699;">matrix-template</span>
<span style="color: #036A07;">"template"</span>
[matrix<span style="color: #999999;">]</span>
<span style="color: #999999;">)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org7d47db7" class="outline-2">
<h2 id="org7d47db7">End</h2>
<div class="outline-text-2" id="text-org7d47db7">
<div class="Q^{-1}UOTE">
<p>
This webpage is generated from an org-document (at <code>./index.org</code>) that also generates all the files described. 
</p>

<p>
Once opened in Emacs:<br>
</p>
<ul class="org-ul">
<li><code>C-c C-e h h</code> generates the webpage  <br></li>
<li><code>C-c C-v C-t</code> exports the code blocks into the appropriate files<br></li>
<li><code>C-c C-c</code>     org-babel-execute-src-block</li>
<li><code>C-c C-v C-b</code> org-babel-execute-buffer</li>
</ul>

</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: George Kontsevich</p>
<p class="date">Created: 2019-07-25 Thu 07:43</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
